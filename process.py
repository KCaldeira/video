# video to midi code
"""
prompt for ChatGTP:

Here's a Python script that processes every Nth frame of a video file, calculates multiple metrics (average intensity, 
standard deviation, and entropy) for each color color_channel (R, G, B, and grayscale) and outputs 24 MIDI files. 
Each metric is stored in two MIDI files: one directly scaled (0-127) and another inverted (127-0).

This script will:

Extract every Nth frame from the video.
Compute various metrics for each color channel.
Map values to MIDI Control Change (CC) messages (both direct and inverted).
Save each metric in a separate MIDI file, with filenames autogenerated.

"""
import cv2
import numpy as np
from mido import Message, MidiFile, MidiTrack
import os
from scipy.stats import entropy

def compute_metrics(frame):
    """
    Compute different intensity-based metrics on R, G, B, and grayscale images.
    Returns a dictionary of results.
    """
    metrics = {}

    # Convert to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Split into R, G, B channels
    b, g, r = cv2.split(frame)

    for name, color_channel in [("R", r), ("G", g), ("B", b), ("Gray", gray_frame)]:
        # Compute metrics
        avg_intensity = np.mean(color_channel)
        std_dev = np.std(color_channel)
        
        # Compute entropy (measure of randomness)
        hist = cv2.calcHist([color_channel], [0], None, [256], [0, 256])
        hist_prob = hist / hist.sum()
        entropy_val = entropy(hist_prob, base=2)

        # Store values
        metrics[f"{name}_avg"] = avg_intensity
        metrics[f"{name}_std"] = std_dev
        metrics[f"{name}_entropy"] = entropy_val

    return metrics

def map_to_midi(value, invert=False):
    """
    Map a value in the range (0-255) to MIDI (0-127).
    If invert=True, reverse the scale (127-0).
    """
    midi_value = int((value / 255) * 127)
    return 127 - midi_value if invert else midi_value

def process_video_to_midi(video_path, 
                          output_prefix, 
                          nth_frame=30, 
                          frames_per_second=30, 
                          ticks_per_beat=480, 
                          tempo=120, 
                          cc_number=7, 
                          midi_channel=0):
    """
    Process every Nth frame, calculate metrics, and generate multiple MIDI files.
    
    :param video_path: Path to the video file.
    :param output_prefix: Prefix for output MIDI filenames.
    :param nth_frame: Process every Nth frame.
    :param frames_per_second (number of frames per second in video)
    :param ticks_per_beat (number of midi ticks per beat in DAW)
    :param tempo (number of beats per minute in DAW)
    :param cc_number: MIDI CC number (default 7 for volume).
    :param channel: MIDI channel (0-15).

    """
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error: Could not open video file.")
        return

    # Define metric categories
    metric_names = ["avg", "std", "entropy"]
    color_channels = ["R", "G", "B", "Gray"]

    # Initialize MIDI files for each metric
    midi_files = {}
    for color_channel in color_channels:
        for metric in metric_names:
            base_filename = f"{output_prefix}_{color_channel}_{metric}"
            midi_files[f"{color_channel}_{metric}"] = MidiFile()
            midi_files[f"{color_channel}_{metric}_inv"] = MidiFile()

            # Add MIDI tracks
            midi_files[f"{color_channel}_{metric}"].tracks.append(MidiTrack())
            midi_files[f"{color_channel}_{metric}_inv"].tracks.append(MidiTrack())

    frame_count = 0
    time_tick = round(ticks_per_beat * (tempo/60.) * (nth_frame/frames_per_second)) # Fixed MIDI time step
    #!!! fix this, make times ticks exact, but then round to find the right frame

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        if frame_count % nth_frame == 0:
            print ("Processing frame:", frame_count)
            metrics = compute_metrics(frame)

            # Write MIDI messages for each metric
            for key, value in metrics.items():
                midi_val = map_to_midi(value, invert=False)
                midi_val_inv = map_to_midi(value, invert=True)

                # Add to the correct MIDI track
                color_channel_name, metric_name = key.split("_")
                midi_files[f"{color_channel_name}_{metric_name}"].tracks[0].append(
                    Message('control_change', 
                            control=cc_number, 
                            value=midi_val, 
                            channel=midi_channel, 
                            time=time_tick)
                )
                midi_files[f"{color_channel_name}_{metric_name}_inv"].tracks[0].append(
                    Message('control_change', 
                            control=cc_number, 
                            value=midi_val_inv, 
                            channel=midi_channel, 
                            time=time_tick)
                )

        frame_count += 1

    cap.release()

    # Save all MIDI files
    for key, midi_file in midi_files.items():
        filename = f"{output_prefix}_{key}.mid"
        midi_file.save(filename)
        print(f"Saved: {filename}")

# Example usage
test_video = "Mz3DllgimbrV2.wmv"

process_video_to_midi(test_video, 
                      "test_midi", 
                      nth_frame=60, 
                      frames_per_second=30, 
                      ticks_per_beat=480, 
                      tempo=120, 
                      cc_number=7, 
                      midi_channel=0)
# process_video_to_midi("path_to_your_video.mp4", "output_prefix", nth_frame=30, frames_per_second=30, ticks_per_beat=480, tempo=120, cc_number=7, channel=0)

