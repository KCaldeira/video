# video to midi code
"""
prompt for ChatGTP:

Here's a Python script that processes every Nth frame of a video file, calculates multiple metrics (average intensity, 
standard deviation, and entropy) for each color channel (R, G, B, and grayscale) and outputs 24 MIDI files. 
Each metric is stored in two MIDI files: one directly scaled (0-127) and another inverted (127-0).

This script will:

Extract every Nth frame from the video.
Compute various metrics for each color channel.
Map values to MIDI Control Change (CC) messages (both direct and inverted).
Save each metric in a separate MIDI file, with filenames autogenerated.

"""
import cv2
import numpy as np
from mido import Message, MidiFile, MidiTrack
import os
from scipy.stats import entropy

def compute_metrics(frame):
    """
    Compute different intensity-based metrics on R, G, B, and grayscale images.
    Returns a dictionary of results.
    """
    metrics = {}

    # Convert to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Split into R, G, B channels
    b, g, r = cv2.split(frame)

    for name, channel in [("R", r), ("G", g), ("B", b), ("Gray", gray_frame)]:
        # Compute metrics
        avg_intensity = np.mean(channel)
        std_dev = np.std(channel)
        
        # Compute entropy (measure of randomness)
        hist = cv2.calcHist([channel], [0], None, [256], [0, 256])
        hist_prob = hist / hist.sum()
        entropy_val = entropy(hist_prob, base=2)

        # Store values
        metrics[f"{name}_avg"] = avg_intensity
        metrics[f"{name}_std"] = std_dev
        metrics[f"{name}_entropy"] = entropy_val

    return metrics

def map_to_midi(value, invert=False):
    """
    Map a value in the range (0-255) to MIDI (0-127).
    If invert=True, reverse the scale (127-0).
    """
    midi_value = int((value / 255) * 127)
    return 127 - midi_value if invert else midi_value

def process_video_to_midi(video_path, output_prefix, nth_frame=30, frames_per_second=30, ticks_per_beat=480, tempo=120, cc_number=7, channel=0):
    """
    Process every Nth frame, calculate metrics, and generate multiple MIDI files.
    
    :param video_path: Path to the video file.
    :param output_prefix: Prefix for output MIDI filenames.
    :param nth_frame: Process every Nth frame.
    :param frames_per_second (number of frames per second in video)
    :param ticks_per_beat (number of midi ticks per beat in DAW)
    :param tempo (number of beats per minute in DAW)
    :param cc_number: MIDI CC number (default 7 for volume).
    :param channel: MIDI channel (0-15).

    """
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error: Could not open video file.")
        return

    # Define metric categories
    metric_names = ["avg", "std", "entropy"]
    channels = ["R", "G", "B", "Gray"]

    # Initialize MIDI files for each metric
    midi_files = {}
    for channel in channels:
        for metric in metric_names:
            base_filename = f"{output_prefix}_{channel}_{metric}"
            midi_files[f"{channel}_{metric}"] = MidiFile()
            midi_files[f"{channel}_{metric}_inv"] = MidiFile()

            # Add MIDI tracks
            midi_files[f"{channel}_{metric}"].tracks.append(MidiTrack())
            midi_files[f"{channel}_{metric}_inv"].tracks.append(MidiTrack())

    frame_count = 0
    time_tick = ticks_per_beat * (tempo/60.) * (nth_frame/frames_per_second)  # Fixed MIDI time step

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        if frame_count % nth_frame == 0:
            metrics = compute_metrics(frame)

            # Write MIDI messages for each metric
            for key, value in metrics.items():
                midi_val = map_to_midi(value, invert=False)
                midi_val_inv = map_to_midi(value, invert=True)

                # Add to the correct MIDI track
                channel_name, metric_name = key.split("_")
                midi_files[f"{channel_name}_{metric_name}"].tracks[0].append(
                    Message('control_change', control=cc_number, value=midi_val, channel=channel, time=time_tick)
                )
                midi_files[f"{channel_name}_{metric_name}_inv"].tracks[0].append(
                    Message('control_change', control=cc_number, value=midi_val_inv, channel=channel, time=time_tick)
                )

        frame_count += 1

    cap.release()

    # Save all MIDI files
    for key, midi_file in midi_files.items():
        filename = f"{output_prefix}_{key}.mid"
        midi_file.save(filename)
        print(f"Saved: {filename}")

# Example usage
process_video_to_midi("input_video.mp4", "output_midi", nth_frame=10)
